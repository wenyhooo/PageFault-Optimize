# 二进制启动优化

测试设备:<br />Target Name: 吴海的iPhone<br />Target Model: iPhone XS Max<br />Target iOS: 13.0 (17A577)

二进制优化，就是优化启动后app的page fault次数<br />
<br />真正的冷启动，是重启手机后的第一次启动，看下面的这几个数据采集：<br />重启手机后第一次启动,数据采集2次：<br />//周一<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/169030/1589274479666-4b585536-8230-454c-a080-e4f7b2cadad6.png#align=left&display=inline&height=160&margin=%5Bobject%20Object%5D&name=image.png&originHeight=320&originWidth=1952&size=73448&status=done&style=none&width=976)<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/169030/1589274959580-2e607f68-1e6f-48c2-88cb-88583d33353c.png#align=left&display=inline&height=169&margin=%5Bobject%20Object%5D&name=image.png&originHeight=338&originWidth=1956&size=72530&status=done&style=none&width=978)<br />
<br />file Backed Page in  就是page fault，缺页异常，异常越多说明启动申请内存的次数越多，耗时就越多

从上图2次启动的数据说明：单纯的杀掉应用再启动并不是真正的冷启动，因为杀掉应用并不能确定系统有没有真正的去回收内存。<br />
<br />下面我们来看看一看，我们app的类和方法的加载顺序<br />进行一次真机编译后，查看linkMap和build phases 发现两个顺序一致<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/169030/1588939855676-d5b5e9c8-2ced-44bf-815b-528bb25771c5.png#align=left&display=inline&height=261&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2408&originWidth=3540&size=2083008&status=done&style=none&width=383)![image.png](https://cdn.nlark.com/yuque/0/2020/png/169030/1588939899751-6ee75f7b-1f4a-4d64-8b5a-67b92fe0223b.png#align=left&display=inline&height=260&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2414&originWidth=2572&size=704566&status=done&style=none&width=277)<br />
<br />
<br />我们再继续查看linkMap文件下面的 # Symbols  方法加载顺序<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/169030/1588940285033-db2604b8-5947-40de-8cee-efbd3b710d53.png#align=left&display=inline&height=633&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2592&originWidth=2208&size=873994&status=done&style=none&width=539)<br />看到这个列表，发现编译器生成mach O文件时已经生成了函数排列顺序，系统会按照一页16K的大小来分配内存加载，前面99%的方法，其实我们启动时并没有用到，但是却因为排列靠前，却不得不提前加载触发page fault，可能我们启动时用到的方法只需要1000页就行了，但却因为这个顺序的缘故造成了我们分配了3000次。

我们下面要做的就是进行方法加载重排，找出app启动过程中调用到的方法，并且指定machO优先加载顺序，减少启动时page fault的发生，提升app加载速度.<br />
<br />参考[http://www.zyiz.net/tech/detail-127196.html](http://www.zyiz.net/tech/detail-127196.html)<br />Other c添加-fsanitize-coverage=func,trace-pc-guard，经过 clang 插桩 ，抓取到app启动时所调用到的函数，并生成snake.order， 然后在Order File指定文件为snake.order，再次编译后的link map # Symbols<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/169030/1589014491750-d45c79c5-44bf-459b-8c1b-725080db581a.png#align=left&display=inline&height=585&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1466&originWidth=938&size=326828&status=done&style=none&width=374)![image.png](https://cdn.nlark.com/yuque/0/2020/png/169030/1589014449113-0b365aa5-26e5-4cb2-8d07-6f66cb85d7b6.png#align=left&display=inline&height=312&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1394&originWidth=1634&size=489989&status=done&style=none&width=366)<br />经过对比，两者完全一致，符合预期。<br />
<br />再重启手机跑instrumets <br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/169030/1589275316091-f83ad11c-89f9-4fb9-9ca8-3a7dc968bb90.png#align=left&display=inline&height=161&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=1950&size=71982&status=done&style=none&width=975)<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/169030/1589275503920-024c26bf-f3a8-4e98-8f45-fb9285367c5d.png#align=left&display=inline&height=154&margin=%5Bobject%20Object%5D&name=image.png&originHeight=308&originWidth=1958&size=74262&status=done&style=none&width=979)<br />太难测试了，每次跑都有出入，同一个包 反复重启设备也是忽高忽低<br />大约iphonexr max 平均每次启动减少400次  page fault，按照业界0.1 ~ 1.0 ms 取一个平均值0.5，  400*0.5 = 0.2s, 按照page fault次数来算，提升效率约为8%

设置一下DYLD_PRINT_STATISTICS_DETAILS<br />再看一下pre main阶段：<br />
<br />**优化前：**<br />**  total time: 3.6 seconds **(100.0%)<br />**  total images loaded:  576 **(562 from dyld shared cache)<br />**  total segments mapped: 51**, into 2778 pages<br />**  total images loading time: 1.7 seconds **(47.7%)<br />**  total load time in ObjC:  35.90 milliseconds **(0.9%)<br />**  total debugger pause time: 1.6 seconds **(44.4%)<br />**  total dtrace DOF registration time:   0.00 milliseconds **(0.0%)<br />**  total rebase fixups:  1**,142,624<br />**  total rebase fixups time:  83.46 milliseconds **(2.2%)<br />**  total binding fixups: 136**,355<br />**  total binding fixups time:  24.60 milliseconds **(0.6%)<br />**  total weak binding fixups time: 734.01 milliseconds **(20.1%)<br />**  total redo shared cached bindings time:  32.28 milliseconds **(0.8%)<br />**  total bindings lazily fixed up: 0 of 0**<br />**  total time in initializers and ObjC +load: 1.0 seconds **(28.1%)<br />**                         libSystem.B.dylib :   3.96 milliseconds **(0.1%)<br />**               libBacktraceRecording.dylib :   5.39 milliseconds **(0.1%)<br />**                libMainThreadChecker.dylib :  25.22 milliseconds **(0.6%)<br />**                      libglInterpose.dylib : 335.16 milliseconds **(9.2%)<br />**                       libMTLCapture.dylib :   5.51 milliseconds **(0.1%)<br />**                                 snakeGame : 1.2 seconds **(33.2%)<br />**total symbol trie searches:    6070954**<br />**total symbol table binary searches:    0**<br />**total images defining weak symbols:  59**<br />**total images using weak symbols:  139**<br />**<br />**优化后的：**<br />**  total time: 3.3 seconds **(100.0%)<br />**  total images loaded:  575 **(561 from dyld shared cache)<br />**  total segments mapped: 51**, into 2778 pages<br />**  total images loading time: 1.5 seconds **(45.5%)<br />**  total load time in ObjC:  35.74 milliseconds **(1.0%)<br />**  total debugger pause time: 1.4 seconds **(42.7%)<br />**  total dtrace DOF registration time:   0.00 milliseconds **(0.0%)<br />**  total rebase fixups:  1**,142,009<br />**  total rebase fixups time:  84.96 milliseconds **(2.5%)<br />**  total binding fixups: 136**,289<br />**  total binding fixups time:  26.53 milliseconds **(0.7%)<br />**  total weak binding fixups time: 732.43 milliseconds **(21.7%)<br />**  total redo shared cached bindings time:  31.97 milliseconds **(0.9%)<br />**  total bindings lazily fixed up: 0 of 0**<br />**  total time in initializers and ObjC +load: 953.59 milliseconds **(28.3%)<br />**                         libSystem.B.dylib :   6.80 milliseconds **(0.2%)<br />**               libBacktraceRecording.dylib :   5.56 milliseconds **(0.1%)<br />**                libMainThreadChecker.dylib :  25.35 milliseconds **(0.7%)<br />**                      libglInterpose.dylib : 331.53 milliseconds **(9.8%)<br />**                       libMTLCapture.dylib :   6.30 milliseconds **(0.1%)<br />**                                 snakeGame : 1.0 seconds **(31.7%)<br />**total symbol trie searches:    6070788**<br />**total symbol table binary searches:    0**<br />**total images defining weak symbols:  59**<br />**total images using weak symbols:  139**

total time 大约减少了0.3s，按照时间算，效率大约提升8%

